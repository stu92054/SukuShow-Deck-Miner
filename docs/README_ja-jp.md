# SukuShow Deck Miner

[
Link！Like！ラブライブ！](https://www.lovelive-anime.jp/hasunosora/system/) (リンクラ) 内のリズムゲームモード、スクールアイドルショウ (スクショウ) 向けのデッキシミュレーターおよび最適化ツールです。

---

**[English](../README.md) | [简体中文](README_zh-cn.md) | [繁體中文](README_zh-tw.md) | [日本語](README_ja-jp.md)**

---

## 🚀 クイックスタート

### 🛞 動作環境

- **Python バージョン**:  
  `match ... case ...` ステートメントを使用しているため、本プロジェクトは **Python 3.10 以降** が必須です。  
  **最適なパフォーマンスを得るには、Python 3.11 以降での実行を強く推奨します。**

- **依存パッケージ**:

  - `PyYAML` - YAML設定ファイルの解析用
  - `tqdm` - 一括シミュレーション時の進捗バー表示用

  以下のコマンドでインストールできます：

  ```bash
  pip install PyYAML tqdm
  ```

- **PyPyによるパフォーマンス最適化**（オプションですが推奨）：

  標準のCPythonの代わりにPyPyを使用すると、大幅なパフォーマンス向上が得られます（場合によっては **3-5倍の高速化**）：

  1. [PyPy 3.10+](https://www.pypy.org/download.html)をダウンロードしてインストール
  2. PyPyのpipで依存パッケージをインストール：
     ```bash
     pypy -m pip install PyYAML tqdm sortedcontainers
     ```
     **注意**：`sortedcontainers`はPyPy環境でのみ必要で、標準CPythonでは不要です。
  3. PyPyでシミュレーターを実行：
     ```bash
     pypy MainBatch.py
     # または
     pypy MainSingle.py
     ```

  **注意**：PyPyのJITコンパイラは計算集約型シミュレーションに優れたパフォーマンスを提供しますが、ウォームアップ段階では多くのメモリを使用する可能性があります。

---

## 🎮 使い方

### ▶ 主要スクリプトの実行

ご自身のニーズに基づいて、以下のファイルを選択して実行してください：

- `MainBatch.py`: **一括シミュレーション**。カードプールと課題曲を入力し、自動でデッキを生成して一括シミュレーションを実行します。**単曲での最適デッキ**を見つけるのに役立ちます。
- `MainSingle.py`: **単一シミュレーション**。特定のデッキと課題曲を入力し、一度だけシミュレーションを実行して詳細なプロセスを出力します。
- `multi_song_optimizer.py`: **複数曲最適化**。複数の課題曲を入力し、`MainBatch.py` で生成されたデッキスコアデータを利用して、**複数曲間での最適な組み合わせ**を見つけます。

### ⚙ カスタム設定

#### 🆕 設定ファイルシステム（ギルドメンバー計算に推奨）

**複数のギルドメンバーのシミュレーションを行う必要があるユーザー向け**に、YAMLベースの設定システムを提供しており、異なるメンバーの設定を簡単に切り替えることができます：

**クイックスタート：**

1. **各ギルドメンバーの設定ファイルを作成：**
   ```bash
   copy config\member-example.yaml config\member-yourname.yaml
   ```

2. **設定ファイルを編集**して、メンバーのカードプール、ファンレベル、カード練度に合わせます：
   ```yaml
   # config/member-yourname.yaml

   songs:
     - music_id: "405117"
       difficulty: "02"        # 01=Normal, 02=Hard, 03=Expert, 04=Master
       mastery_level: 50

     - music_id: "405118"      # 複数曲追加可能
       difficulty: "03"

   card_ids:
     - 1011501  # メンバーが所有するすべてのカードをリスト
     - 1021701
     # ...

   fan_levels:
     1011: 5    # メンバーのファンレベル
     1021: 3
     # ...

   card_levels:
     # 特定のカード練度を上書き（最大レベルでない場合）
     # 1021701: [130, 10, 10]  # LR梢 最大レベルでない
   ```

3. **設定を使用してシミュレーションを実行：**
   ```bash
   python MainBatch.py --config config/member-yourname.yaml
   ```

4. **結果は自動的に分離されたディレクトリに保存されます：**
   ```
   # 最終結果（永久保存）
   log/
   └── {member_name}/              # 例: alice/ (member-*.yaml 使用時)
       └── simulation_results_405117_02.json

   # 一時ファイル（実行中、完了後にクリーンアップ可能）
   temp/
   └── {member_name}/              # log/ と一致
       └── {timestamp}/            # 実行タイムスタンプ
           └── temp_405117/        # 各楽曲ごとの独立ディレクトリ
               └── temp_batch_001.json
   ```

**メリット：**
- ✅ **簡単な切り替え** - 異なるギルドメンバーのシミュレーションを素早く実行
- ✅ **コード変更不要** - すべての設定はYAMLファイル内
- ✅ **分離された出力** - 各実行で独立したディレクトリを作成（ファイル競合なし）
- ✅ **Git フレンドリー** - 設定ファイルをバージョン管理にコミット可能

**設定の優先順位：**
1. コマンドライン：`python MainBatch.py --config config/member1.yaml`
2. 環境変数：`set CONFIG_FILE=config/member1.yaml`（Windows）または `export CONFIG_FILE=config/member1.yaml`（Linux）
3. デフォルト：`config/default.yaml`（存在する場合、git で無視）
4. CardLevelConfig.py とプログラム内設定（従来の方法、下位互換性あり）

**注意：** `config/default.yaml` は gitignore されています。`config/default-example.yaml` をテンプレートとして使用し、独自の `config/default.yaml` を作成してください。

**ギルド計算のワークフロー例：**
```bash
# メンバー Alice の計算
python MainBatch.py --config config/member-alice.yaml

# メンバー Bob の計算
python MainBatch.py --config config/member-bob.yaml

# 結果は別々のディレクトリに：
# log/alice/simulation_results_*.json
# log/bob/simulation_results_*.json
#
# 一時ファイル：
# temp/alice/{timestamp}/temp_*/
# temp/bob/{timestamp}/temp_*/
```

詳細は `config/member-example.yaml` の完全な例を参照してください。

---

#### 従来の方法：直接ファイルを変更

Pythonファイルで直接設定を調整することもできます：

- [src/config/CardLevelConfig.py](../src/config/CardLevelConfig.py): すべてのカードの**デフォルト練度**と**個別のカード練度** (`CARD_CACHE`) を設定します。デフォルトでは、すべてのカードが最大レベルに設定されています。
また、`DEATH_NOTE` を利用して背水カードの放置HPラインを構成できます。デッキ内に複数の背水カードが設定されている場合、最も低いHPラインが適用されます。
- [src/deck_gen/DeckGen2.py](../src/deck_gen/DeckGen2.py): デッキ生成ロジックを扱います。ここでカードの競合ルール (`CARD_CONFLICT_RULES`) やデッキスキル条件 (`check_skill_tags`) などの制約を設定し、デッキ生成時のさらなる枝刈り最適化を実現できます。
- [MainBatch.py](../MainBatch.py): **一括シミュレーションの主要な設定ファイル。** 詳細な設定ガイドは以下を参照してください。
- [MainSingle.py](../MainSingle.py): 単一シミュレーションのデッキと楽曲を設定します。
また、`logging.basicConfig` でシミュレーション過程のログ出力レベルを調整できます。
    - `INFO`: デッキとシミュレーション結果のみを出力します。
    - `DEBUG`: 詳細なスキル使用記録を出力します。
    - `TIMING`: すべてのノートおよびCD終了時点を含むログを出力します。ノート数が多いため、画面が流れる可能性があるため、ログをテキストファイルに出力して確認することをお勧めします。
- [src/core/Simulator_core.py](../src/core/Simulator_core.py): 何をしているかを理解している限り、コードを直接調整して一括シミュレーション時の音ゲープレイ戦略を調整できます。ここでの変更は一括シミュレーションにのみ影響し、單一シミュレーションの戦略は `MainSingle.py` で別途変更する必要があります。

### 📘 MainBatch.py 設定ガイド

`MainBatch.py`の実行前には手動での設定が必要です。以下が変更すべき主な項目です：

#### 1. **カードプール設定** (約157行目)
シミュレーションに含めるカードを定義：

```python
card_ids = [
    1011501,  # カードID例
    1033514,
    # ここにお持ちのカードIDを追加
]
```

#### 2. **楽曲設定** (約208行目)
シミュレーションする1曲または複数曲を設定：

```python
SONGS_CONFIG = [
    {
        "music_id": "405305",        # 楽曲ID（ゲームデータから取得）
        "difficulty": "02",          # 難易度："01"=Normal, "02"=Hard, "03"=Expert, "04"=Master
        "mustcards_all": [],         # すべてのデッキに必須のカード（カードIDリスト）
        "mustcards_any": [],         # 少なくとも1枚は含む必要があるカード
        "center_override": None,     # センターキャラを上書き（None = 楽曲デフォルト）
        "color_override": None,      # 楽曲カラーを上書き：1=Smile, 2=Pure, 3=Cool（None = 楽曲デフォルト）
    },
    # 必要に応じて楽曲を追加
]
```

#### 3. **シーズンファンレベル設定** (約285行目)
グランプリPt計算の精度向上のため、ファンレベルを設定：

```python
# シーズンモード：'sukushow'（歌唱メンバーのみ）または 'sukuste'（全メンバー）
SEASON_MODE = 'sukushow'

# 各キャラクターのファンレベル（1-10）を設定
FAN_LEVELS: dict[int, int] = {
    1011: 10,  # キャラクターID -> ファンレベル
    1021: 8,
    1022: 10,
    # 全12キャラクターのファンレベルを追加
    # 未指定の場合はデフォルトで10
}
```

**ファンレベルボーナステーブル：**
- レベル1: 0%
- レベル2: 20%
- レベル3: 27.5%
- レベル4: 35%
- レベル5: 42.5%
- レベル6: 50%
- レベル7: 55%
- レベル8: 60%
- レベル9: 65%
- レベル10: 70%（デフォルト）

#### 4. **DR剪定設定** (約196行目)
センターキャラ以外のDRカードを削除するかどうかを制御：

```python
ENABLE_DR_PRUNING = False  # 推奨：False（アルゴリズムに決定させる）
# True:  センター以外のDRを削除 + センターDRを強制（旧動作）
# False: すべてのDRを保持し、アルゴリズムが最適な使用法を決定
```

#### 5. **スキル要件** (約236行目)
生成されるすべてのデッキに必要なスキルタイプを指定：

```python
mustskills_all = [
    SkillEffectType.DeckReset,  # デッキリセット（DR）
    SkillEffectType.ScoreGain,  # スコアブースト
    # 他の必須スキルタイプを追加
]
```

---

## ⚠️ **重要警告：CPU 使用率と安定性** ⚠️

> [\!CAUTION]  
> ⚠ **一括シミュレーションはデフォルトで利用可能なすべての CPU スレッドを使用し、実行中の CPU 使用率は通常 99% を超えます。** ⚠  
> **Intel i5-13600KF プロセッサにおいて、長時間フルロードで動作させた後にブルースクリーン（BSOD）が発生した事例が報告されています。**
>
> ご使用の CPU の安定性や冷却に自信がない場合は、**一括シミュレーションを実行する前に以下の対策を強く推奨します**：
>
> - CPU の**電圧を上げる/クロックを下げる**操作を行う。  
> - シミュレーターが使用する**スレッド数を減らす**。 
>
> 予防策として、`MainBatch.py` ファイル内の `num_processes = os.cpu_count() or 1` の行を `num_processes = 12` に変更することができます。`12` は一例であり、パフォーマンスの負荷を軽減するために、ご使用の CPU の**合計スレッド数未満の任意の数値**に置き換えることが可能です。

- **リソースに関する考慮事項**: 理論的には、すべてのカードをカードプールに含めて一括シミュレーションを実行することも可能です。しかし、そのためには**極めて強力な CPU 性能、膨大な RAM 容量、そして十分なシミュレーション時間**が必要です。予期せぬ問題が発生する可能性もあるため、この方法は**おすすめできません**。
- **メモリ使用量**: 一括シミュレーションにおけるデッキ生成とシミュレーションのプロセスはパイプライン形式で動作し、結果もバッチごとに一時的にディスクに保存されますが、**カードの枚数が多いほど、シミュレーターが消費するメモリ量も多くなります**。そのため、メモリ不足エラーを避けるために、カードプールにあまり多くのカードを含めすぎないようご注意ください。

---

## 📝 備考と潜在的な差異

- このシミュレーターは、**総当たり探索**でデッキを生成しシミュレーションを実行します。見つかる「単曲での最適デッキ」は、**与えられたカードプール、練度、難易度、および音ゲープレイ戦略**の下でのみ有効です。カードプールや練度、または譜面難易度を調整すると、異なる最適デッキが見つかる可能性があります。デフォルトで採用されている音ゲープレイ戦略は以下の通りです。
  1.  譜面の正確なタイミングで**All Perfect**を達成する。
  2.  デッキ内に`DEATH_NOTE`でHPラインが設定された背水カードがある場合、現在のHPがそのラインを上回っている間は自動で放置し、HPがラインを下回ってからAll Perfectを維持する。
- 同様に、複数曲での最適解も、カードプール、練度、譜面難易度、音ゲープレイ戦略などの要因によって変動します。
- このシミュレーターを使えば、**ゲーム内でのリハーサル時間を大幅に短縮**できます。しかし、たった一度の試行で**絶対的な最適デッキ**に辿り着くのは、なかなか難しいです。シミュレーターの真価を発揮させるためには、カードスキルへの深い理解が欠かせません。
- **最適デッキ ≠ 最適戦略**。厳密なタイミング合わせや、フレーム単位でのスコア詰め、あるいはスキル条件や効果に応じたカードの練度調整など、シミュレーターでは測れない部分は、ぜひご自身で突き詰めてみてください。
- **グランプリ Pt**の計算時、シーズンファンレベルボーナスは`MainBatch.py`の`FAN_LEVELS`設定に基づいて**動的に計算**されます。未指定の場合、すべてのメンバーがレベル10としてデフォルト設定されます（旧デフォルト値6.6に相当）。センターメンバー（存在する場合）の解放ボーナスは、そのスキルやSPレベルに基づいて換算されます。
- シミュレーターは**ゲームのロジックを完全に再現しているわけではありません**。そのため、シミュレーションスコアが実際のゲーム内スコアと異なる場合がある点は、あらかじめご了承ください。

### ⏰ 潜在的な誤差要因

**ロジックの不一致**  
オリジナルのゲームロジックを完全に再現できていないため、スキル処理やスコア計算の結果が実プレイと大きく異なる可能性があります。  
**実際のプレイ動画、詳細なデッキ練度、および楽曲のマスター Lv. 情報**をご提供いただければ、不一致を検証し、修正を試みる場合があります。

**時間処理の誤差**  
**浮動小数点精度問題**またはその他の不明な理由（例えば、ゲームが各イベントの正確なタイムスタンプではなく、フレームごとにすべてのイベントを処理している可能性など）により、実際のスキル発動タイミングが**シミュレーションより数十 ms 早く/遅れる**可能性があります。極端な例として、シミュレーションでは FEVER 直前に発動したボルテージスキルが、実際には FEVER 開始後に発動してしまうケースがあります。これにより、FEVER 开始時に発動したセンタースキルに、肝心のボルテージバフを奪われてしまう、といった事象も報告されています。

**判定タイミング**  
シミュレーターは、判定が Perfect であるかどうかに関わらず、譜面内の正確な`just`タイミングでノートを処理します。  
しかし、実際のゲームプレイでは判定には**時間窓**が存在します。AP が不足している場合、これによりスキル発動タイミングがわずかに早まったり遅れたりする可能性があり、極端なケースではシミュレーションよりもカードの発動回数が増減する可能性があります。  
FEVER 開始・終了時と同一拍にあるノートは、フレーム単位での「最適化」を行うことで、FEVER の 2 倍ボルテージボーナスを得られることがあります。ただ、譜面上のノートのタイムスタンプが実際の FEVER 切り替え時間からわずかにずれているため、シミュレーション上では FEVER 内で処理されない場合があります。  
Ver.4.0.1 時点での判定タイミングを以下の表に示します。参考にご覧ください。

<table>
  <thead>
    <tr>
      <th rowspan="2"><b>判定</b></th>
      <th colspan="3"><b>判定タイミング (ms)</b></th>
    </tr>
    <tr>
      <th><i>Single / Hold</i></th>
      <th><i>Flick</i></th>
      <th><i>Trace</i></th>
    </tr>
  </thead>
  <tbody align="center">
    <tr>
      <td>Perfect</td>
      <td>0 ~ ±40</td>
      <td>0 ~ ±70</td>
      <td>0 ~ ±70</td>
    </tr>
    <tr>
      <td>Great</td>
      <td>±40 ~ ±70</td>
      <td>±70 ~ ±100</td>
      <td>－</td>
    </tr>
    <tr>
      <td>Good</td>
      <td>±70 ~ ±100</td>
      <td>タップのみ</td>
      <td>－</td>
    </tr>
    <tr>
      <td>Bad</td>
      <td>±100 ~ ±125</td>
      <td>－</td>
      <td>－</td>
    </tr>
    <tr>
      <td>Miss</td>
      <td>±125 ~</td>
      <td>±100 ~</td>
      <td>±70 ~</td>
    </tr>
  </tbody>
</table>
