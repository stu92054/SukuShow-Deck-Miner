# SukuShow Deck Miner

A deck simulator and optimizer for the rhythm game mode, School Idol Show („Çπ„ÇØ„Ç∑„Éß„Ç¶), within [Link\! Like\! LoveLive\!](https://www.lovelive-anime.jp/hasunosora/system/) („É™„É≥„ÇØ„É©).

---

**[English](README.md) | [ÁÆÄ‰Ωì‰∏≠Êñá](README_zh-cn.md) | [ÁπÅÈ´î‰∏≠Êñá](README_zh-tw.md) | [Êó•Êú¨Ë™û](README_ja-jp.md)**

---

## üöÄ Quick Start

### üõû Prerequisites

- **Python Version**:  
  This project **requires Python 3.10 or newer** because it uses `match ... case ...` statements.  
  **For optimal performance, running with Python 3.11 or later is highly recommended.**

- **Dependencies**:

  - `PyYAML` - For parsing YAML configuration files
  - `tqdm` - For displaying progress bars during batch simulations

  You can install them using the command below:

  ```bash
  pip install PyYAML tqdm
  ```

- **Performance Optimization with PyPy** (Optional but Recommended):

  For significantly faster execution (up to **3-5x speedup** in some cases), you can use PyPy instead of standard CPython:

  1. Download and install [PyPy 3.10+](https://www.pypy.org/download.html)
  2. Install dependencies using PyPy's pip:
     ```bash
     pypy -m pip install PyYAML tqdm sortedcontainers
     ```
     **Note**: `sortedcontainers` is only required for PyPy, not for standard CPython.
  3. Run the simulator with PyPy:
     ```bash
     pypy MainBatch.py
     # or
     pypy MainSingle.py
     ```

  **Note**: PyPy's JIT compiler provides excellent performance for compute-intensive simulations, but it may use more memory initially during warm-up.

---

## üéÆ Usage

### ‚ñ∂ Run Core Scripts

Choose and run the following files depending on what you need:

- `MainBatch.py`: **Batch Simulation**. Input your card pool and target song to automatically generate decks and run batch simulations to find the **optimal deck for a single song**.
- `MainSingle.py`: **Single Simulation**. Input a specific deck and target song to run a single simulation and output the detailed simulation process.
- `multi_song_optimizer.py`: **Multi-Song Optimization**. Input multiple target songs and use the deck scores generated by `MainBatch.py` to find the **optimal combination across multiple songs**.

### ‚öô Custom Configuration

#### üÜï Configuration File System (Recommended for Guild Members)

**For users who need to run simulations for multiple guild members**, we provide a YAML-based configuration system that allows easy switching between different member configurations:

**Quick Start:**

1. **Create a configuration file for each guild member:**
   ```bash
   copy config\member-example.yaml config\member-yourname.yaml
   ```

2. **Edit the configuration file** to match the member's card pool, fan levels, and card levels:
   ```yaml
   # config/member-yourname.yaml

   songs:
     - music_id: "405117"
       difficulty: "02"        # 01=Normal, 02=Hard, 03=Expert, 04=Master
       mastery_level: 50

     - music_id: "405118"      # You can add multiple songs
       difficulty: "03"

   card_ids:
     - 1011501  # List all cards the member has
     - 1021701
     # ...

   fan_levels:
     1011: 5    # Member's fan levels
     1021: 3
     # ...

   card_levels:
     # Override specific card levels if not max level
     # 1021701: [130, 10, 10]  # LRÊ¢¢ not fully leveled
   ```

3. **Run simulation with the configuration:**
   ```bash
   python MainBatch.py --config config/member-yourname.yaml
   ```

4. **Results are automatically saved to isolated directories:**
   ```
   # Final results (permanently saved)
   log/
   ‚îî‚îÄ‚îÄ {member_name}/              # e.g., alice/ (when using member-*.yaml)
       ‚îî‚îÄ‚îÄ simulation_results_405117_02.json

   # Temporary files (during execution, can be cleaned up after completion)
   temp/
   ‚îî‚îÄ‚îÄ {member_name}/              # Consistent with log/
       ‚îî‚îÄ‚îÄ {timestamp}/            # Execution timestamp
           ‚îî‚îÄ‚îÄ temp_405117/        # Separate directory for each song
               ‚îî‚îÄ‚îÄ temp_batch_001.json
   ```

**Benefits:**
- ‚úÖ **Easy switching** - Quickly run simulations for different guild members
- ‚úÖ **No code modification** - All configurations in YAML files
- ‚úÖ **Isolated outputs** - Each run creates separate directories (no file conflicts)
- ‚úÖ **Version control friendly** - Configuration files can be committed to Git

**Configuration Priority:**
1. Command line: `python MainBatch.py --config config/member1.yaml`
2. Environment variable: `set CONFIG_FILE=config/member1.yaml` (Windows) or `export CONFIG_FILE=config/member1.yaml` (Linux)
3. Default: `config/default.yaml` (if exists, ignored by git)
4. CardLevelConfig.py and in-program settings (legacy method, backward compatible)

**Note:** `config/default.yaml` is gitignored. Use `config/default-example.yaml` as a template to create your own `config/default.yaml`.

**Example workflow for guild calculations:**
```bash
# Calculate for member Alice
python MainBatch.py --config config/member-alice.yaml

# Calculate for member Bob
python MainBatch.py --config config/member-bob.yaml

# Results are in separate directories:
# log/alice/simulation_results_*.json
# log/bob/simulation_results_*.json
#
# Temporary files:
# temp/alice/{timestamp}/temp_*/
# temp/bob/{timestamp}/temp_*/
```

See `config/member-example.yaml` for a complete example.

---

#### Legacy: Direct File Configuration

You can also adjust configurations directly in Python files as needed:

  - `CardLevelConfig.py`: Configure the **default levels** for all cards and **specific levels for individual cards** (`CARD_CACHE`). By default, all cards are set to max level.
  You can also use `DEATH_NOTE` to configure the AFK HP threshold for comeback cards. If multiple comeback cards with configured thresholds are in the deck, the lowest threshold will be used.
  - `DeckGen2.py`: Handles deck generation logic. You can configure constraints like card conflict rules (`CARD_CONFLICT_RULES`) and deck skills (`check_skill_tags`) here to further optimize deck generation by pruning.
  - `MainBatch.py`: **Primary configuration file for batch simulations.** See the detailed configuration guide below.
  - `MainSingle.py`: Configure the specific deck and song for a single simulation.
  You can also adjust the log output verbosity in `logging.basicConfig`.
      - `INFO`: Outputs only the deck and simulation results.
      - `DEBUG`: Outputs detailed skill usage records.
      - `TIMING`: Outputs logs including all note and CD end timestamps. Since notes can flood the console, it's recommended to output the logs to a text file for review.
  - `Simulator_core.py`: You can modify the code here to adjust the rhythm game strategy for batch simulations, as long as you know what you're doing. Note that changes made here only affect batch simulations; the strategy for single simulations must be modified separately in `MainSingle.py`.

### üìò MainBatch.py Configuration Guide

`MainBatch.py` requires manual configuration before running. Here are the key sections to modify:

#### 1. **Card Pool Configuration** (Line ~157)
Define which cards to include in the simulation:

```python
card_ids = [
    1011501,  # Example card ID
    1033514,
    # Add your available card IDs here
]
```

#### 2. **Song Configuration** (Line ~208)
Configure one or multiple songs to simulate:

```python
SONGS_CONFIG = [
    {
        "music_id": "405305",        # Song ID (find in game data)
        "difficulty": "02",          # Difficulty: "01"=Normal, "02"=Hard, "03"=Expert, "04"=Master
        "mustcards_all": [],         # Cards that MUST be in every deck (list of card IDs)
        "mustcards_any": [],         # At least ONE of these cards must be in deck
        "center_override": None,     # Override center character (None = use song default)
        "color_override": None,      # Override song color: 1=Smile, 2=Pure, 3=Cool (None = use song default)
    },
    # Add more songs as needed
]
```

#### 3. **Season Fan Level Configuration** (Line ~285)
Configure fan levels for accurate Grandprix Pt calculation:

```python
# Season mode: 'sukushow' (only singing members) or 'sukuste' (all members)
SEASON_MODE = 'sukushow'

# Set fan level (1-10) for each character
FAN_LEVELS: dict[int, int] = {
    1011: 10,  # Character ID -> Fan Level
    1021: 8,
    1022: 10,
    # Add all 12 characters with their fan levels
    # Default is 10 if not specified
}
```

**Fan Level Bonus Table:**
- Level 1: 0%
- Level 2: 20%
- Level 3: 27.5%
- Level 4: 35%
- Level 5: 42.5%
- Level 6: 50%
- Level 7: 55%
- Level 8: 60%
- Level 9: 65%
- Level 10: 70% (default)

#### 4. **DR Pruning Configuration** (Line ~196)
Control whether to remove non-center character DR cards:

```python
ENABLE_DR_PRUNING = False  # Recommended: False (let algorithm decide)
# True:  Remove non-center DR cards + force center DR (old behavior)
# False: Keep all DR cards, algorithm decides optimal usage
```

#### 5. **Skill Requirements** (Line ~236)
Specify which skill types must be present in all generated decks:

```python
mustskills_all = [
    SkillEffectType.DeckReset,  # Deck reset (DR)
    SkillEffectType.ScoreGain,  # Score boost
    # Add other required skill types
]
```

---

## ‚ö†Ô∏è **Important Warning: CPU Usage & Stability** ‚ö†Ô∏è

> [\!CAUTION]  
> ‚ö† **Batch simulations by default utilize all available CPU threads, and CPU usage typically exceeds 99% during runtime.** ‚ö†  
> **We've observed cases where an Intel i5-13600KF processor experienced a BSOD after prolonged full-load operation.**  
>
> If you are not confident in your CPU's stability or cooling, **it's highly recommended to take the following measures before running batch simulations**:
>
> - **Increase voltage / downclock** your CPU.
> - **Reduce the number of threads** used by the simulator.
>
> As a precautionary measure, you can modify the line `num_processes = os.cpu_count() or 1` in `MainBatch.py` to `num_processes = 12`. The value `12` is an example; you can replace it with **any other value less than your CPU's total thread count** to reduce performance pressure.

- **Performance Considerations**: Technically, you could include all available cards in the card pool for batch simulation. However, this demands **extremely powerful CPU performance, a large amount of RAM, and ample simulation time**. Due to potential unforeseen issues, this approach is **not recommended**.
- **Memory Usage**: Although deck generation and simulation stages in batch processing operate as a pipeline and temporarily cache results to the disk, **the more cards you use, the more memory the simulator will consume**. Therefore, please do not include too many cards in the selection pool to avoid out-of-memory errors.

---

## üìù Notes & Potential Discrepancies

- This simulator uses an **exhaustive search method** to generate and simulate decks. The "optimal deck for a single song" it finds is only valid under the **given card pool, card levels, difficulty, and rhythm game strategy**. Adjusting the card pool, levels, or difficulty may yield a different optimal deck. The default strategy is:
  1.  Achieve **All Perfect** at the precise timing specified in the chart.
  2.  If the deck contains comeback cards configured in `DEATH_NOTE`, the simulator will idle automatically when the current HP is above the comeback threshold, and maintain All Perfect only when HP falls below that threshold.
- Similarly, the optimal solution for multiple songs will also change with the card pool, levels, difficulty, and rhythm game strategy.
- The simulator effectively **saves time on in-game rehearsal**, but it's difficult to find the **absolute optimal deck** in a single attempt. A good understanding of card skills is required to fully utilize the simulator's potential.
- **Optimal Deck ‚â† Optimal Strategy**. For strategies involving precise timing, frame-by-frame scoring optimization, or adjusting card skill levels based on skill conditions/effects, please use your own discretion.
- When calculating **Grandprix Pt**, the Season Fan Lv bonus is **dynamically calculated** based on the `FAN_LEVELS` configuration in `MainBatch.py`. If not specified, it defaults to level 10 for all members (equivalent to the old default of 6.6). The limitbreak multiplier for the center character (if exists) is calculated based on their skill or SP level.
- As the simulator **does not 1:1 perfectly replicate in-game logic**, it's normal for simulated scores to differ from actual in-game scores.

### ‚è∞ Possible Sources of Error

**Logic Inconsistencies**  
Because the simulator doesn‚Äôt perfectly replicate the game logic, there may be significant differences in skill processing and score calculation results compared to actual play.
If you can provide **actual play recordings, detailed deck levels, and song Master Lv. information**, I might attempt to verify the inconsistencies and provide fixes.

**Time Processing Errors**  
Due to **floating-point precision issues** or other unknown reasons (for example, the game might process all events once per frame rather than precisely at each event's exact timestamp), **actual skill activation timing might be earlier/later** than simulated.  
In extreme cases, skills might activate just before Fever in simulation but only after Fever begins in actual play. This can result in Voltage/Score bonus being consumed by a Center Skill that triggers at Fever's start.  

**Judgment Timing**  
The simulator only processes notes at their precise `just` timing in the chart, regardless of whether the judgment is Perfect.
However, in-game judgment has a **time window**. When AP is not enough, this might cause skill activation timings in actual play to be slightly earlier/later, potentially leading to one more/less skill activation than in simulation in extreme cases.  
For notes that fall on the same beat as the start/end of Fever, frame-by-frame "optimizing" can sometimes allow them to receive the double Voltage bonus from Fever. However, the recorded timestamp of these notes in the chart is usually a few decimal places off from the actual Fever transition time, which might lead to them not being processed within Fever during simulation.  
The table below shows judgment timings as of Ver.4.0.1.

<table>
  <thead>
    <tr>
      <th rowspan="2"><b>Judgement</b></th>
      <th colspan="3"><b>Judgement Timing (ms)</b></th>
    </tr>
    <tr>
      <th><i>Single / Hold</i></th>
      <th><i>Flick</i></th>
      <th><i>Trace</i></th>
    </tr>
  </thead>
  <tbody align="center">
    <tr>
      <td>Perfect</td>
      <td>0 ~ ¬±40</td>
      <td>0 ~ ¬±70</td>
      <td>0 ~ ¬±70</td>
    </tr>
    <tr>
      <td>Great</td>
      <td>¬±40 ~ ¬±70</td>
      <td>¬±70 ~ ¬±100</td>
      <td>Ôºç</td>
    </tr>
    <tr>
      <td>Good</td>
      <td>¬±70 ~ ¬±100</td>
      <td>Tap but no Up-Flick</td>
      <td>Ôºç</td>
    </tr>
    <tr>
      <td>Bad</td>
      <td>¬±100 ~ ¬±125</td>
      <td>Ôºç</td>
      <td>Ôºç</td>
    </tr>
    <tr>
      <td>Miss</td>
      <td>¬±125 ~</td>
      <td>¬±100 ~</td>
      <td>¬±70 ~</td>
    </tr>
  </tbody>
</table>
